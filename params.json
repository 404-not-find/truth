{"body":"Truth\r\n=====\r\n***We've made failure a strategy***\r\n\r\n**Continuous Integration:** [![Build Status](https://truth.ci.cloudbees.com/job/Truth0-truth-master/badge/icon)](https://truth.ci.cloudbees.com/job/Truth0-truth-master/)<br />\r\n**Latest Release:** *0.10*<br />\r\n**Latest Artifact:** *org.junit.contrib:truth:jar:0.10*<br />\r\n\r\n**Note:** Truth is subject to change and prior to 1.0, may introduce \r\nbreaking changes.  We're getting closer to \"prime time\" but please \r\nuse with caution before release 1.0.  Consider Truth in alpha.\r\n\r\n<!--- Generated TOC by http://doctoc.herokuapp.com/ -->\r\n\r\n###***Table of Contents***\r\n\r\n- [Introduction](#introduction)\r\n- [Installation](#installation)\r\n- [Using Truth](#using-truth)\r\n\t- [Super basics](#super-basics)\r\n\t- [Failure Strategy](#failure-strategy)\r\n\t- [How does Truth work?](#how-does-truth-work)\r\n\t- [Extensibility](#extensibility)\r\n\t- [Categorically testing the contents of collections](#categorically-testing-the-contents-of-collections)\r\n\t- [Some code examples](#some-code-examples)\r\n\t\t- [Basic objects](#basic-objects)\r\n\t\t- [Booleans](#booleans)\r\n\t\t- [Numerics](#numerics)\r\n\t\t- [Strings](#strings)\r\n\t\t- [Iterables, Collections, Sets, and the like.](#iterables-collections-sets-and-the-like)\r\n- [Planned improvements and changes](#planned-improvements-and-changes)\r\n\r\nIntroduction\r\n------------\r\n\r\nTruth is a testing framework suitable for making assertions and assumptions\r\nabout code.  Truth adopts a fluent style for your test propositions, is \r\nextensible in several ways, supports IDE completion/discovery of available\r\npropositions, and supports different responses to un-true propositions.\r\nTruth can be used to declare assumptions (skip the test if they fail),\r\nassertions (fail the test), and expectations (continue but report errors \r\nand fail at the end).\r\n\r\nWhile intended to work with JUnit, Truth can be used with other testing\r\nframework with minimal effort.  Truth is released as a maven artifact \r\nthrough a custom repository (it will be released to repo1.maven.org soon),\r\nand is licensed with the Apache 2.0 open-source license.  As such, you are\r\nfree to use it or modify it subject only to the terms in that license.\r\n\r\nInstallation\r\n------------\r\n\r\nTo prepare to use Truth, declare this dependency:\r\n\r\n    <dependency>\r\n      <groupId>org.truth0</groupId>\r\n      <artifactId>truth</artifactId>\r\n      <version>0.10</version>\r\n    </dependency>\r\n\r\nAs of truth 0.9 Truth is available in the Maven Central Repository.\r\n\r\nor download the jar directly from the link below and add it to\r\nyour tests classpath\r\n\r\n    http://search.maven.org/remotecontent?filepath=org/truth0/truth/0.10/truth-0.10.jar\r\n\r\nUsing Truth\r\n-----------\r\n*A brief and basic tutorial*\r\n\r\n###Super basics\r\n\r\nTruth is used in a literate style.  One can use truth most simply \r\nto replace JUnit assertions (and to handle the dreaded \"MoreAsserts\")\r\nproblem where a team must increasingly create more static assert\r\nlibraries to handle complex cases.  \r\n\r\nMost simply, replacing a JUnit assert like this:\r\n\r\n    assertTrue(blah.isSomeBooleanValue());\r\n\r\ncan be done with the following:\r\n\r\n    Truth.ASSERT.that(blah.isSomeBooleanValue()).isTrue();\r\n\r\n... or with static imports, this can be shortened to the preferred usage:\r\n\r\n    ASSERT.that(blah.isSomeBooleanValue()).isTrue();\r\n\r\nThis may not seem like a saving, but for two things.  One, it reads, in \r\nenglish, precisely what it means.  And secondly, many assertTrue() calls \r\nare hiding more meaningful assertions, like this:\r\n\r\n    assertTrue(blah > 5);\r\n\r\nIn Truth, you would tend to extract all of these:\r\n\r\n    ASSERT.that(blah).isMoreThan(5);\r\n\r\nAnd where one might write:\r\n\r\n    assertTrue(blah.isEmpty());\r\n\r\nTruth would have you write:\r\n\r\n    ASSERT.that(blah).isEmpty();\r\n\r\n### Failure Strategy\r\n\r\nTruth treats failure as data - a proposition was not true... so now what?\r\nWell, that depends on the failure strategy.  Truth supports a few different\r\nstrategies for handling failure, and has different strategies baked in to\r\npre-built TestVerbs exposed as static final fields.  The standard strategies \r\nare:\r\n\r\n<table>\r\n  <tr>\r\n    <th>Strategy</th>\r\n    <th>Constant</th>\r\n    <th>Behaviour</th>\r\n    <th>Framework supported</th>\r\n    <th>Notes</th>\r\n  </tr>\r\n  <tr>\r\n    <td>Assertion</td>\r\n    <td>Truth.ASSERT</td>\r\n    <td>Aborts and fails test, reports failure</td>\r\n    <td>JUnit, TestNG, others (untested)</td>\r\n    <td />\r\n  </tr>\r\n  <tr>\r\n    <td>Assumption</td>\r\n    <td>Truth.ASSUME</td>\r\n    <td>Aborts and ignores/skips test</td>\r\n    <td>JUnit</td>\r\n    <td />\r\n  </tr>\r\n  <tr>\r\n    <td>Expectation</td>\r\n    <td>Expect.create()</td>\r\n    <td>Continues test, reports errors and failure upon test completion</td>\r\n    <td>JUnit</td>\r\n    <td>You must declare an @Rule per the ExpectTest</td>\r\n  </tr>\r\n</table>\r\n\r\n*Note:* These different styles can let a developer build more supple tests,\r\nthough the Truth team recommends mostly using ASSERT in unit tests,\r\nand very careful consideration of ASSUME and EXPECT.  These can make \r\none's tests quite expressive and clear, but ASSUME can cause tests \r\nto not be run (unexpectedly), and EXPECT can encourage the developer\r\nto test propositions about way too many things, causing big heavy \r\ntests, rather than lots of small, clear tests.   \r\n\r\n### How does Truth work?\r\n\r\nTruth presents you with a test verb (ASSERT and ASSUME are built in, and\r\nEXPECT is supported with JUnit4 @Rules).  The verb is asserting on a subject,\r\nthe value to be considered.  \r\n\r\n    ASSERT.that(thisSubject)\r\n\r\nOnce Truth has a subject, it has a known type, and can therefore reason\r\nat compile time about what propositions are known about that subject. For\r\ninstance, integers, longs, booleans, strings, and various flavours of \r\ncollections all have different kinds of things you want to know about them.\r\nBecause Truth knows about these types at compile time, it returns a \"Subject\"\r\nwrapper around your value, which declares proposition methods such as \"contains\"\r\nor \"isMoreThan\" or \"isEmpty\" etc.  These allow your IDE to suggest available\r\ncompletions. \r\n\r\n### Extensibility\r\n\r\nBut what if a proposition isn't supported for the desired type?  Or the\r\ntype is not a part of Truth's basic types at all?  How can a developer\r\nuse Truth on \"TheirCustomObject\"?\r\n\r\nTruth uses two means to do this.  The simplest is not recommended, but is\r\nquick and dirty and can get the job done.  That's simply to extend AbstractVerb\r\nor TestVerb and declare their own custom ASSERT field containing this custom\r\nverb.  That verb can implement more \"that(Sometype t)\" overrides to support\r\ncustom types, or even to provide a different Subject wrapper for the already\r\nsupported types. (see [Extensibility through Subclassing][])\r\n\r\nA more literate approach, and one which doesn't require creating a new\r\nTestVerb (allowing reuse of ASSERT, ASSUME, and EXPECT) is to use this syntax:\r\n\r\n    ASSERT.about(SOME_TYPE).that(thatValue).hasSomePropositionalValue();\r\n\r\nSOME_TYPE here is actually a SubjectFactory - an interface which can be\r\nimplemented to provide a custom Subject wrapper.  Creating a SubjectFactory\r\nfor use in this approach is pretty easy, and you can follow the example\r\ngiven it the [Extension through delegation][] example.\r\n\r\nFor convenience, you can create a static final SOME_TYPE field so you \r\ncan use it less-verbosely in ASSERT.about();  Existing Subject subclasses\r\n(e.g. IntegerSubject, StringSubject, etc.) all have static final\r\nSubjectFactory fields named INTEGER, STRING, etc. You can also follow\r\ntheir example. \r\n\r\n  [Extensibility through Subclassing]: https://github.com/cgruber/truth/tree/documentation/src/test/java/org/junit/contrib/truth/extensiontest\r\n  [Extension through delegation]: https://github.com/cgruber/truth/tree/documentation/src/test/java/org/junit/contrib/truth/delegatetest\r\n\r\n### Categorically testing the contents of collections\r\n*coming in version 0.8*\r\n\r\nSometimes a test needs to look at the contents of a collection \r\nand ensure that characteristics of all a collection's contents\r\nconform to certain constraints.  This can be done with a \r\nfor-each-like approach.\r\n\r\n    ASSERT.in(anIterable).thatEach(STRING).has().item(\"foo\");\r\n\r\nThis lets you pass in an iterable type, and provide a SubjectFactory\r\n(it is advised to use the static final fields for this for readability).\r\nWhen this is invoked, then <code>contains(\"foo\")</code> will be invoked\r\non each element in the iterable in turn, reporting failure as if a \r\nseparate ASSERT.that(anElement).contains(\"foo\") had been invoked for\r\neach element.  Naturally, ASSERT will fail on the first failing element,\r\nASSUME will skip the test on any failing element, and EXPECT will \r\ngather all failures and report them at the end of the test.\r\n\r\nThis approach can be used for custom types too, so long as they have\r\na SubjectFactory\r\n\r\n    public static final SubjectFactory<MyCustomSubject, MyType> MY_TYPE = ...;\r\n    ... \r\n    ASSERT.in(someIterable).thatEach(MY_TYPE).doesSomething();\r\n\r\nThe same extensibility provided in <code>ASSERT.about(MY_TYPE).that()...</code>\r\nis available to the developer over iterables of that type.\r\n\r\n### Some code examples\r\n\r\nThese are not exhaustive examples, but commonly used propositions.  Please check out \r\nthe Javadocs for the Subject subclasses, or use IDE syntax completion proposals to\r\ndiscover predicates for types you provide as subjects.\r\n\r\n#### Basic objects\r\n\r\nEquality is simply \"is\" in Truth.  \r\n\r\n    ASSERT.that(this).is(that);\r\n\r\nType information is as usual:\r\n\r\n    ASSERT.that(this).isA(MyObject.class);\r\n\r\nOften propositions have negative forms:\r\n\r\n    ASSERT.that(this).isNotA(String.class);\r\n\r\nNullness is checked simply with:\r\n\r\n    ASSERT.that(something).isNull();\r\n    ASSERT.that(somethingElse).isNotNull();\r\n\r\nFields' presence and their values can *(as of 0.8)* be checked with:\r\n\r\n    ASSERT.that(something).hasField(\"foo\").withValue(\"bar\");\r\n    \r\nThis should work even with private fields, and can be useful in testing \r\ngenerated properties created by some frameworks like Lombok and Tapestry.\r\n\r\n#### Class objects\r\n\r\n    ASSERT.that(aClass).declaresField(\"foo\");\r\n    \r\n + <em>Note, do not use <strong>hasField()</strong> on Class objects, as you will be \r\n   testing whether Class.class itself has that field, not whether the \r\n   type it represents declares that field.  A deprecation warning should\r\n   notify you of this usage, but be careful, and use <strong>declaresField(\"foo\")</strong>\r\n   instead.<em>\r\n\r\n#### Booleans\r\n\r\n    ASSERT.that(something).isTrue();\r\n    ASSERT.that(something).isFalse();\r\n\r\n#### Numerics\r\n\r\n    ASSERT.that(5).isBetween(4, 5);\r\n    ASSERT.that(5).isExclusivelyInRange(4, 6);\r\n\r\n#### Strings\r\n\r\n    ASSERT.that(aString).contains(\"blah\");\r\n    ASSERT.that(aString).startsWith(\"foo\");\r\n    ASSERT.that(aString).endsWith(\"bar\");\r\n\r\n#### Iterables, Collections, Sets, and the like.\r\n\r\n##### Iterables\r\n\r\n    ASSERT.that(anIterable).isEmpty();\r\n    ASSERT.that(anIterable).iteratesOverSequence(a, b, c);\r\n\r\n##### Collections\r\n\r\nOne can simply use object equality if you want to test collection \r\nequivalence, given the guarantees of Collections' implementations of \r\n.equals():\r\n\r\n    ASSERT.that(colectionA).is(collectionB);\r\n\r\nTesting properties like size should be done like so:\r\n\r\n    ASSERT.that(collection.size()).is(5); \r\n\r\nOr you can be more explicit:\r\n\r\n    ASSERT.that(collectionA).has().allOf(a, b, c);\r\n\r\noptionally you can further constrain this:\r\n\r\n    ASSERT.that(collectionA).has().allOf(a, b, c).inOrder();\r\n\r\nOr you can provide some limited \"or\" logic with:\r\n\r\n    ASSERT.that(collectionA).has().anyOf(b, c);\r\n\r\nYou can also pass in collections as expectations, like so:\r\n\r\n    ASSERT.that(collectionA).has().anyFrom(Arrays.asList(a, b));\r\n\r\n##### Lists\r\n\r\nSpecific properties can be proposed on lists, such as:\r\n\r\n    ASSERT.that(myList).isOrdered(); // uses default ordering and is strict, no equal elements.\r\n    ASSERT.that(myList).isPartiallyOrdered(); // like isOrdered, but equal elements may be present.\r\n\r\nAnd custom comparators can be provided\r\n\r\n    ASSERT.that(myList).isOrdered(aComparator); \r\n    ASSERT.that(myList).isPartiallyOrdered(aComparator);\r\n\r\n##### Maps\r\n\r\nPresence of keys, keys for values, or values can be asserted\r\n\r\n    ASSERT.that(map).hasKey(\"foo\");\r\n    ASSERT.that(map).hasKey(\"foo\").withValue(\"bar\");\r\n    ASSERT.that(map).lacksKey(\"foo\");\r\n    ASSERT.that(map).hasValue(\"bar\");\r\n\r\nNaturally, also:\r\n\r\n    ASSERT.that(map).isEmpty();\r\n    ASSERT.that(map).isNotEmpty();\r\n    \r\nTesting properties like size should be done like so:\r\n\r\n    ASSERT.that(map.size()).is(5); \r\n\r\n\r\nPlanned improvements and changes\r\n--------------------------------\r\n\r\n  * Subject wrappers for new types:\r\n    * New subjects for Float/Double and other currently missing types.\r\n\t    * Support for Annotations and methods and field availability on classes.\r\n    * Support for Protocol Buffers, JavaBeans (and other reflective types)\r\n    * Support for Guava collections and types (Multimaps, Multisets, etc.)\r\n  * New propositions on existing Subject wrappers:\r\n    * StringSubject, IntegerSubject, etc.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Assertion/Proposition framework for Java unit tests","google":"","name":"Truth"}